%notfulltexdoc
\section{Implementation}

\subsection{The Beginning of the Pipeline: Handling the STM32 Discovery Board}
The STM32F407 Discovery Board is the microcontroller that the user interacts with. As discussed
previously, this board is responsible for gathering accelerometer and microphone data to send
through the pipeline. 
%%Written by Matthew, April 20
\subsection{Smart Phone Android Application}

Given that the Nucleo board has no WiFi/Internet capabilities, data must be communicated over BLE to an Android application, that then forwards the data to the web server over HTTP. For convention, this report may use "Android app" to signify the smart phone BLE mobile application. The report also assumes that the reader has basic knowledge of telecommunication protocols, and Android applications. This portion of the report details the implementation and the rationale behind the design of the smart phone application that acts as the intermediary component between the Nucleo board and the web server.\\
With that being said, the requirements for the Android application are the following:

\begin{itemize}
    \item Scan for and connect to BLE peripheral devices;
    \item Enable the user the ability to start, or stop scanning for devices, and connect or disconnect from one peripheral device;
    \item Discover BLE services and characteristics from the peripheral device;
    \item Read voice and accelerometer data batches over BLE from the Nucleo board;
    \item Save the received data to its appropriate file;
    \item Once the accelerometer file contains 10 seconds worth of data, transmit the file to the web server over HTTP;
    \item Once the voice file contains 1 second worth of data, transmit the file to the web server over HTTP;
    \item Handle HTTP responses from the web server and send data to the Nucleo board.
\end{itemize}

Each of the Android application's business-logic features are implemented in the Java programming language, and the user interface is designed in XML. The implementation of the Android application is facilitated by using the Android Studio IDE.\\

\subsubsection{Brief Summary on Android}

The report doesn't go into detail about the code written for the project, if the reader desires to see the source code themselves, they can see it \href{https://github.com/lebrice/MicroP/tree/master/project}{here}. There is documentation written within the code so that the reader may understand the basics of the code written. This report goes into detail about the high level designs and concepts used.\\

Android applications perform in a way such that all user interface and business-logic is performed within an \textit{Activity}. Even if a developer doesn't need a user interface for their application, a main activity must instantiate and start once the user opens the application. Android developers must also declare any build dependencies such as programming libraries and hardware capabilities (such as Bluetooth and Internets) within the \textit{manifest.xml} file. The activity, since there can be multiple activities, which runs on application start up is also declared in the manifest file.\\

\subsubsection{BLE Interface}

In regards to BLE, the smart phone is recognized as the \textit{client device}, and the Nucleo board as the \textit{server device}.\\ 

The first step for any BLE handshaking, is the \textit{Scanning Phase}, which is facilitated by a \textit{BLE Scan Callback}. For the client device to recognize BLE servers, the server must advertise itself and the client must scan for these advertisements. With the push of a \textit{SCAN} button on the Android app user interface, the application enters a scanning mode which, by the help of a \textit{Scan Callback} Java class, saves scanning results as MAC addresses that the Android application could try to connect to. Since scanning is cumbersome on the smart phone's battery, the scanning automatically stops after 10 seconds to save battery life. To facilitate full automation, the Android app automatically stops scanning once it finds the Nucleo board's MAC address and tries to connect to the board. This improves the time required to enable a connection between the client and server since the user doesn't have to look through a list of MAC addresses to find the Nucleo board's address and have to select that specific address.\\

The last phase for the BLE handsaking is the connection phase, which is facilitated by a \textit{GATT Client Callback}, where GATT stands for \textit{General Attribute}. Once the Android app finds the Nucleo board, it automatically tries to connect to it, the GATT Client Callback takes charge of this operation. On the press of a CONNECT toggle button, the user can decide to connect or disconnect from the selected peripheral device.\\

The GATT Client Callback handles any connection events, and outputs statuses such as \textit{Connection Success} and \textit{Connection Failure}. Since there isn't any authentication procedure between client and server devices, the GATT Client Callback simply notifies the server that it wishes to connect to it and once the server, by the help of a GATT Server Callback, receives the notification, and responds with a connection success. If somehow the connection is a failure, the Android application simply logs the result to the Android Studio debug console. Although, on a connection success, the Android application now starts to search for \textit{Services} that the server may be transmitting. If the service used to package voice and accelerometer data is discovered, and contains their appropriate \textit{Characteristics}, the Android application is ready to read and be notified by any updates to the voice and accelerometer data.\\

At this point, the smart phone is connected to the Nucleo board over a BLE session and can now start to transmit data to one another! Exciting, if I do say so myself.

\subsubsection{Handling Data}

The Android app receives data in a byte array which is packaged under a characteristic assigned for either voice or accelerometer data. The batch of data is then written to its appropriate file with the help of the \texttt{AppController.java} class.\\

To send files over HTTP, the Android app makes use of the \href{https://developer.android.com/training/volley/index.html}{Volley Library} to create and configure HTTP requests, while also handling any HTTP responses. This is useful if the developers wish to send files conveniently over HTTP as well as receive data from the web server over HTTP. The developers wished to keep data uploading simple. By encoding the file-to-be-sent into a base-64 string and adding the encoding to the HTTP request's form, the web server can easily retrieve the file from the request by reading and decoding the form body.

\subsubsection{Summary of Project, Structure and Classes}

One can see a visualization of the Android app project structure in
\hyperref[fig:androidstructure]{Figure \ref{fig:androidstructure}}. Of course there are many files related to the application that couldn't be referenced under this report due to sizing constraints, any three dots represents that.\\

\usetikzlibrary{trees}
\tikzstyle{every node}=[draw=black,thick,anchor=west,inner sep=2pt,minimum size=1pt]
\tikzstyle{selected}=[draw=cyan,fill=cyan!30]
\begin{figure}[h]
	\caption{Overview of the Android File Hierarchy}\label{fig:androidstructure}
	\begin{tikzpicture}[
	  grow via three points={one child at (0.5,-0.7) and
	  two children at (0.5,-0.7) and (0.5,-1.4)},   
	  edge from parent path={(\tikzparentnode.south) |- (\tikzchildnode.west)}]
	  \node {main}
		child { node [draw=none] {\ldots}}
		child { node [draw=none] {AndroidManifest.xml} }
		child { node [draw=none] {build.gradle} }
		child { node [label={[xshift=6.0cm, yshift=-0.58cm, color=gray]}] {res}
			child { node [draw=none] {\ldots}}
		}
		child [missing] {}
		child { node [label={[xshift=6.0cm, yshift=-0.58cm, color=gray]}] {java}
			child { node [label={[xshift=6.0cm, yshift=-0.58cm, color=gray]}] {com}
				child { node [label={[xshift=6.0cm, yshift=-0.58cm, color=gray]}] {ecse426}
					child { node [label={[xshift=6.0cm, yshift=-0.58cm, color=gray]}] {project}
						child { node [label={[xshift=6.0cm, yshift=-0.58cm, color=gray]}] {app}
							child { node [draw=none] {ClientActivity.java} }
							child { node [draw=none] {AppController.java} }
						}
						child [missing] {}
						child [missing] {}
						child { node [label={[xshift=6.0cm, yshift=-0.58cm, color=gray]}] {utils}
							child { node [label={[xshift=6.0cm, yshift=-0.58cm, color=gray]}] {batches}
							   child { node [draw=none] {AccBatch.java} } 
							   child { node [draw=none] {MicBatch.java} }
							}
							child [missing] {}
							child [missing] {}
							child { node [draw=none] {GattUtils.java} }
							child { node [draw=none] {LRUBitmapCache.java} }
							child { node [draw=none] {WaveFileTools.java} }
						}
					}
				}
			}
		};
	\end{tikzpicture}
\end{figure}
\tikzstyle{every node}=[] % resets borders of tables
\tikzstyle{selected}=[] % resets selected
The \texttt{AndroidManifest.xml} is the manifest file specific to this application which contains dependencies. The \texttt{build.gradle} file is the gradle build script, Android Studio automatically runs its build configurations whenever the developer runs or builds the application.\\

The \texttt{ClientActivity.java} class is the main activity that runs on start up. It is the core of the application, every other class is written around it and is used to help it. This class contains the BLE Scan Callback and GATT Client Callback logic implemented under inner classes. It handles user input and contains function calls from other classes that receive and save data over BLE and HTTP.\\

The \texttt{AppController.java} handles HTTP requests by facilitating the Client Activity with a queue for requests. It also handles reading and writing voice and accelerometer data to their appropriate files. It is important to note that the \texttt{AppController.java} class extends the Application class, making it able to run simultaneously with the \texttt{ClientActivity.java} class and have data persist when the application is closed.\\

The \texttt{AccBatch.java} and \texttt{MicBatch.java} classes are helper classes that contain functions to convert accelerometer or voice data respectively from bytes to a data type instructed by the function. The \texttt{GattUtils.java} class contains GATT Service, Characteristic, and Configuration UUIDs, as well as the Nucleo board's MAC address. The \texttt{WaveFileTools.java} class handles reading and writing data from and to files of Wave format. The \texttt{LRUBitmapCache.java} class is supposed to send and receive files, unfortunately it is not used.\\

Under the \texttt{res} directory, one can find all the user interface layouts and images. Any user interface design or image is found under that directory. 
