\section{Implementation}

This section will describe the design and engineering processes that were used while implementing our system, based on the requirements described above. In order to simplify and structure its description, the system will first be broken down into its different logical components.\\


\subsection{High-Level System Architecture}


The various requirements and corresponding program functionality of our system can be broken down into four main areas: the 7-segment display, the keypad, the ADC and the PWM controller. The keypad and display components were implemented as Threads, each behaving as a simple finite-state-machine. The ADC and PWM-related logic components were implemented as a part of an Interrupt-Service-Routine (ISR).\\

Despite the overall system having significant complexity, its high-level behaviour can be broken down into a very limited number of states. The transitions between each state were also well defined (as part of the Section \ref{section:problem_statement}). By taking advantage of this fact, a very simple state machine was created, where each state manages to turn each sub-component "on" or "off". A state diagram showing the three system states, along with the name of their transitions and their outputs can be seen in Figure \ref{fig:high_level_state_diagram}.


\begin{figure}[h]
\centering
\begin{tikzpicture}[shorten >=1pt,node distance=4cm,on grid,auto] 
   \node[state with output,initial] (sleep)  {$Sleep$ \nodepart{lower} $1000$}; 
   \node[state with output] (input_target)	[below right=of sleep]	{$Input$ \nodepart{lower} $1100$}; 
   \node[state with output] (match_voltage) 	[below left=of sleep]	{$Match$ \nodepart{lower} $1111$};
   \path[->] 
   		(sleep) edge [bend left] node {WakeUp()} (input_target)
        (input_target) edge node {Sleep()} (sleep)
        (input_target) edge [bend left] node {StartMatching()} (match_voltage)
        (input_target) edge [loop right] node {Reset()} ()
        (match_voltage) edge node {Sleep()} (sleep)
        (match_voltage) edge node {Reset()} (input_target)
    ;  
    \draw node [below=4.5cm,midway,text width=8cm,text centered]
      {Output: [Keypad|Display|ADC|PWM]};
\end{tikzpicture}
\caption{System high-level state diagram}
\label{fig:high_level_state_diagram}
\end{figure}




\begin{tabular}{ p{0.33\textwidth} | p{0.33\textwidth} | p{0.33\textwidth}}
Sleep & Input & Match \\
\hline
% Sleep state description 
The sleep state is the initial state of the system. In this state, the only active component is the keypad thread. All other components (display, ADC, PWM timer) are turned off, in order to conserve energy. Whenever a keypress is detected, the system transitions into the 'input' state.
&
% Input state description
During the "input" state, the Keypad thread detects button presses and updates the target value accordingly, while the Display thread shows the current target value. The Keypad and Display threads are active, while the ADC and PWM timer are turned off. Whenever a valid voltage value is entered, the system transitions into the "match" state.
&
% Match state state description
When the system enters the "match" state, the PWM timer and ADC are both started. After each \verb|HAL_ADC_ConvCpltCallback()| interrupt service routine, the ADC samples are filtered and their RMS is extracted. This value is fed to the PWM controller, which modifies the period of the PWM timer in order to attempt to reach the target voltage.
\\
\end{tabular}


The associated code for this finite state machine can be found within the \href{https://github.com/lebrice/MicroP/blob/master/Lab4/Src/fsm.c}{fsm.c} file. Every major component of the system will now be examined individually.


\subsection{Display Thread}

\def \DISPLAYREFRESHINTERVAL {8ms}

The logic used in the Display thread was almost all created as part of Lab 2. A state diagram of the display FSM can be seen Figure \ref{fig:display_state_diagram}. Its main logic, as shown in Figure \ref{fig:display_thread_main_logic}, can be found within the \href{https://github.com/lebrice/MicroP/blob/master/Lab4/Src/display_thread.c}{display\_thread.c} file. \\ 



\begin{figure}[h]
\begin{minipage}{0.40\textwidth}
	\begin{tikzpicture}[shorten >=1pt,node distance=3cm,on grid,auto] 
		\node[state,initial] (off)  {$Off$};
		\node[state, initial] [below=of off] (digit_0) {$Digit\_0$};
		\node[state] [below right=of digit_0] (digit_1) {$Digit\_1$};
		\node[state] [below left=of digit_0] (digit_2) {$Digit\_2$}; 
		\node[fit=(digit_0) (digit_1) (digit_2), rectangle, fill=black!10, draw=black, fill opacity=0.3, label=left:\fbox{On}] (on) {};
		\path[->]
			(off) 		edge [bend left] node {start\_display()} (on)
			(on) 		edge [bend left] node {stop\_display()} (off)
			(digit_0) 	edge node {\DISPLAYREFRESHINTERVAL} (digit_1)
			(digit_1) 	edge node {\DISPLAYREFRESHINTERVAL} (digit_2)
			(digit_2) 	edge node {\DISPLAYREFRESHINTERVAL} (digit_0)
			;
	\end{tikzpicture}
	\label{fig:display_state_diagram}
	\caption{Display thread state diagram}
\end{minipage}\hfill
\vrule
\begin{minipage}{0.45\textwidth}
	\begin{lstlisting}[
	language=C,
	basicstyle=\small,
	xleftmargin={0.2cm},
	tabsize=1,
]
void StartDisplayTask(void const * arguments){
  // Which digit is currently active.
  static uint8_t currently_active_digit = 0;
	
  while(true){
    osSignalWait(display_on, osWaitForever);
    	while(display_on){
    	  // while the display is on, refresh it.
    	  refresh_display(currently_active_digit);
    	  osDelay(DISPLAY_REFRESH_INTERVAL_MS);
    	  currently_active_digit++;
    	  currently_active_digit %= 3;
    	}
    	// DISPLAY IS NOW OFF!
    	RESET_PIN(DIGITS_0);
    	RESET_PIN(DIGITS_1);
    	RESET_PIN(DIGITS_2);
  }
}
	\end{lstlisting}
	\caption{Main Display thread logic}
	\label{fig:display_thread_main_logic}
\end{minipage}\hfill
\end{figure}



This thread calls the \verb|osSignalWait| function in order to be blocked until the \verb|display_on| variable is set externally, at which point the thread is resumed, and the refreshing cycle begins. Refreshing the display consists of setting the pin associated with the currently active digit high, along with the required segment pins for the corresponding digit of the \verb|displayed_value| variable. This variable may contain either the target value, if the system is currently in the \verb|"Input"| state, or the current RMS, when in the \verb|"match"| state. Since there is no contention for the display, the use of a synchronization variable (a semaphore, for instance) is not needed. The system may only be one of the two states at a time. After a digit is set, the thread goes to sleep for \verb|DISPLAY_REFRESH_INTERVAL_MS| (\DISPLAYREFRESHINTERVAL).






\subsection{Keypad Thread}

\subsection{ADC Logic}

\subsection{PWM Timer}