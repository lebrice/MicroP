\section{Testing and Observations}
\label{section:testing_and_observations}

Our first component that required testing was the keypad which did not have a formal spec sheet and required us to figure out which output pin was set by the buttons on the keypad. To debug this we set the keypad buttons to the display to see which button would light up. With the buttons assigned we can now focus on de-bouncing of the digit presses. This could be done by making sure that each user press was at least 200ms long so that no short unintended press would be registered. Furthermore, to enter consecutive numbers the user would need to press a second time with a 200ms pause between presses to let the controller know that a `no-char' character is pressed and a consecutive repeating character is a new character and not a continuation of the initial digit press.
We initially implemented an additional thread for our ADC that would wake up as soon as the DMA buffer full callback was executed by setting a flag. This through testing however showed that the ADC thread would end up blocking the other threads from executing and eventually block our whole program. Figure ? bellow shows our program output and shows the display and keypad threads getting called until only the ADC thread output is shown.
\todo[inline]{add picture here}
To overcome this blocking thread we decided to just keep our ADC DMA processing in a service routine called after every full buffer callback instead of relying on raising the flag to wake up the ADC thread. With this implementation the keypad and display threads would work properly without the blocking that previously occurred.
The next component to test was our PWM wave generated by timer 3. We connected the oscilloscope to the positive terminal of the diode and plotted the wave form. Seen in Figure ? we can see that our duty cycle was around $25%$ and 
\todo[inline]{add oscilloscope duty cycle picture}

Our first controlled was modified from the idea introduced in the Theory and Hypothesis and can be seen working in Figure ?. Because this controller adjusts the duty cycle based off of the difference between measured and target RMS values, it doesn't reach the target RMS value near the end of the adjustments.
\todo[inline]{first Controller picture HERE}
In contrasts to the first implemented controller our second one uses a Binary Search approach that tends to overshoot and re-correct as seen in Figure ?. Although this controller is much faster than our first one, it does overshoot which may not be ideal depending on the direct implementation this controller may be used in. For the purposes of this project is it adequate.
\todo[inline]{second Controller picture HERE}
