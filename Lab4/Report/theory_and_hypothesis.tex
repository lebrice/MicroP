\section{Theory and Hypothesis}
The main component of this experiment is the Pulse Wave Modulation (PWM) which would apply a voltage across a load and a capacitor. The PWM has a set cycle time that we picked to be faster than the time constant of our circuit. The equation bellow is used to calculate the time constant of an RC circuit. $$\tau = RC$$ During this cycle we can choose the duty cycle, or the time the voltage is turned on during the total cycle time of our PWM unit. With our capacitor and resistive load in place the capacitor would collect charge during the active duty cycle of our PWM pulse, and then dissipate its charge during the rest of the PWM cycle. 
Would the duty cycle of the PWM start at 0, there would be no active high voltage outputted by the timer during the cycle. This would give a calculated RMS value of 0 volts. By increasing the duty cycle of the PWM pulse we can start to introduce a voltage for a portion of the PWM cycle. This would charge the capacitor and have it then discharge on the off duty cycle time, leading to a larger RMS value. Figure ? bellow shows the charging of the capacitor during the active duty cycle of our rectifier circuit. 

\todo[inline]{add picture here}

With our PWM timer created, we need a controller to compare our measured RMS with the target RMS value given by the user via keypad. This controller would then see if the duty cycle needed to be increased or decreased based on if the measured RMS value was above or bellow our target. The implementation of this controller would be quite simple as it just needs to compare two values in order to determine which action to perform.

\lstset{language=C}
\begin{lstlisting}

if(calculated_RMS < target_RMS){
	HAL_TIM_PWM_ConfigChannel(++); //increase Duty Cycle
} else{
	HAL_TIM_PWM_ConfigChannel(--); //decrease Duty Cycle
}
\end{lstlisting}

Due to the frequency we picked for our PWM pulse, we needed to pick an appropriate ADC value to ensure that we were picking up the changes applied by our controller. Our ADC frequency needs to be lower than that of our PWM timer so that the ADC samples seemingly random voltages in Figure ? above. With multiple random samples taken across multiple PWM cycles our converted ADC values will give an accurate combined RMS calculation of our collected data points.
With our resistor and capacitor having values $4.7k\Omega$ and $0.1\mu F$ the time constant is calculated to be $\tau = (4.7k\Omega)(0.1\mu F) = 0.470 ms$.
Therefore picking a PWM timer frequency of $10kHz$ which gives us one clock cycle every $0.1 ms$ which is faster than the time constant needed for our controller to receive an accurate RMS value from our ADC.
To pick an ADC value we just need to follow our constraint above that the ADC have a lower frequency than the PWM timer.
\begin{equation}
 Timer freq. = \frac{Clock freq.}{(prescaler + 1) * period}
\end{equation}
With a prescaler of 83 and period of 1000 the Timer frequency of the ADC comes out to be $1kHz$ which falls within our system constraints.

The second aspect of this lab was to implement threads into our system. We did this using the FreeRTOS (Real Time Operating System) kernel. This would make available a middle ware that would be able to schedule and handle the creations of threads and free up our CPU. The advantages of running multiple threads concurrently means that our display thread (which takes care of refreshing our display with the appropriate user input value or measured RMS value of our circuit) and our keypad thread can coexists. Another advantage of running threads in our system is that we are no longer dependent off of the internal Systick clock. 
The ADC thread is also something that we considered implementing with raising a flag once our DMA buffer was filled that would wake up a thread to compute the RMS value. Whether to implement this in a thread or ISR is equivalent and will depend on the implementation and testing of our system.

 